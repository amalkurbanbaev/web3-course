# Задание 3

Минтинг NFT коллекции

## ТЗ

Компания MetaLamp выпускает свою коллекцию NFT. Пользователи смогут получить NFT из этой коллекции в 3 этапа - Airdrop, Private presale, Public sale. Необходимо реализовать:
1. Интерфейс минтинга NFT в 3 этапа для пользователей. 
2. Административную панель для владельца продукта, который будет управлять этапами минтинга и whitelists. 

Каждый этап может быть в одном из 3х состояний - Soon, Available, Finished. Ограничений на очерёдность этапов нет. Теоретически все 3 этапа могут быть одновременно Available, этим будет управлять владелец продукта в админ панели. Но в базовом случае, очерёдность этапов следующая - Airdrop, Private presale, Public sale. 

- На этапе Airdrop счастливчики, которые попали в airdrop whitelist, смогут сминтить (mint) 2 NFT из коллекции бесплатно (заплатив только за газ). Для этого им нужно всего лишь нажать на кнопку mint на нашем сайте и подтвердить в кошельке транзакцию на минтинг двух NFT. Так же в админ панели, владелец продукта должен иметь возможность добавлять и убирать людей из airdrop whitelist.
- На этапе Private presale, другие счастливчики, которые попали в private presale whitelist, смогут купить до 3х NFT за более выгодную цену, чем на этапе Public Sale. Покупка происходит за нативную валюту сети (например для мейннета это ETH). Теперь пользователь может ввести количество NFT для покупки (не больше 3х) и нажать кнопку mint, с дальнейшим подтверждением транзакции в кошельке. Пользователь может купить токены на всём периоде действия этого этапа. То есть, если пользователь сначала купил 1 NFT, а через неделю вернулся и этап всё ещё доступен, он может докупить оставшиеся 2 NFT. Так же в админ панели, владелец продукта должен иметь возможность добавлять и убирать людей из private presale whitelist.
- На этапе Public sale, токены из NFT коллекции наконец сможет купить любой желающий, кто попадёт на наш сайт. Стоимость будет выше, чем на этапе Private presale, а ограничение количества NFT на одного пользователя станет 10 токенов. Пользователь также может купить токены на всём периоде действия этого этапа.
- На всю NFT коллекцию есть ограничение в 10000 токенов, которые могут быть сминчены пользователями.
- У пользователя должна быть возможность просмотреть все NFT из нашей коллекции, которые есть у него на кошельке.


## Смарт-контракт

Для реализации функционала, описанного выше, был разработан смарт-контракт. Адрес контракта запросите у вашего тех лида. На реальном проекте вам необходимо будет общаться с разработчиком смарт контракта, что бы он вам рассказал как и что работает. На данном же проекте, для вашего удобства, ниже представлено описание некоторых методов этого смарт контракта на чтение и запись. Если у вас появятся вопросы по смарт-контракту, задайте их вашему тех лиду. 

### Работа с ролями

У владельца продукта должна быть возможность управлять этапами продаж NFT и вайтлистами через админ панель. Для этого на контракте был реализован классический, для смарт контрактов, функционал ролей. Есть следующие роли:

- `DEFAULT_ADMIN_ROLE` - главная роль на контракте. Только аккаунты с этой ролью могут выдавать (`grantRole`) и забирать (`revokeRole`) роли на контракте. Запросите у вашего техлида эту роль.
- `SELL_PHASE_MANAGER_ROLE` - роль, позволяющая вызывать методы по управлению фазами продаж.
- `WHITE_LIST_MANAGER_ROLE` - роль, позволяющая вызывать методы по управлению вайтлистами.
- `PRICE_MANAGER_ROLE` - роль, позволяющая вызывать методы по управлению ценами на этапах public и private.

Каждой роли соответствует строка `bytes32`, узнать которую можно, вызвав соответствующий метод на контракте (`DEFAULT_ADMIN_ROLE`, `SELL_PHASE_MANAGER_ROLE` и т.д.). 

Методы на чтение:

- `hasRole` - получает строку `bytes32` роли и адрес кошелька, проверяя наличие указанной роли у переданного кошелька. Возвращает булевое значение.

Методы на запись может вызвать только адрес с `DEFAULT_ADMIN_ROLE`:

- `grantRole` - выдаёт указанную роль (`bytes32`) на указанный адрес кошелька.  
- `revokeRole` - забирает указанную роль (`bytes32`) у указанного адрес кошелька. 
- `renounceRole` - позволяет отозвать роль у самого себя. 

### Работа с этапами продаж

Этапами продаж может управлять только адрес с ролью `SELL_PHASE_MANAGER_ROLE`. У каждого этапа продаж может быть одно из 3х состояний - 0, 1, 2, где 0 - Soon, 1 - Available, 2 - Finished.

Методы на чтение:

- `airDrop` - состояние этапа airdrop, от 0 до 2.
- `whiteListSale` - состояние этапа private presale, от 0 до 2.
- `publicSale` - состояние этапа public sale, от 0 до 2.

Методы на запись:

- `toggleAirDrop` - переключает состояние этапа airdrop, принимает цифру от 0 до 2.
- `toggleWhiteListSale` - переключает состояние этапа private presale, принимает цифру от 0 до 2.
- `togglePublicSale` - переключает состояние этапа public sale, принимает цифру от 0 до 2.

### Работа с вайтлистами и Merkle Tree

Два из трёх этапа доступны только пользователем, которые попали в соответствующий whitelist. Управление вайтлистами будет происходить в админ панели при помощи дерева Меркла (Merkle Tree) и библиотеки `merkletreejs`. У админа должен быть простой интерфейс, в котором он сможет просто добавлять и удалять адреса из двух вайтлистов и устанавливать новый вайтлист на контракт. А под капотом будет происходить работа с деревом Меркла. 

Листья дерева в нашем случае - это захэшированные адреса кошельков пользователей при помощи функции `keccack256`. Создать дерево можно следующим образом: 

```ts
import { MerkleTree } from 'merkletreejs';
import { keccak256 } from 'viem';

const merkleTree = new MerkleTree(
  [
    '0x0000000000000000000000000000000000000000', // адреса кошельков
    '0x0000000000000000000000000000000000000000',
    '0x0000000000000000000000000000000000000000',
  ],
  keccak256,
  { hashLeaves: true, sortPairs: true },
);
```

После чего необходимо получить корень дерева - `merkleTree.getHexRoot()` и вызвать соответствующий метод на контракте - `setMerkleRootAirDrop` или `setMerkleRootWhiteList`. Метод будет вызываться админом и таким образом, мы установим на контракт Root hash для каждого этапа, по которому контракт будет проверять, есть ли пользователь в вайтлисте или нет.

Так же для того, что бы вызывать методы `claimAirdrop`, `whitelistMint`, `canClaimAirDrop` и `isWhiteListed` - вам понадобится передавать в них массив `proof`. Каждому листку дерева Меркла (каждому кошельку) соответствует свой массив `proof`. Получить его можно следующим образом - `merkleTree.getHexProof(keccak256(address))`. 

Так как дерево Меркла создаётся в админ панели, а массив `proof` необходимо использовать в основном приложении, то встаёт вопрос о том, где и как хранить массив `proof` для каждого адреса из вайтлиста. Так как у нас нет своей базы данных, то воспользуемся децентрализованным хранилищем - IPFS. Данные будут храниться в формате JSON в следующем виде: 

```json
{
  "airdrop": [
    {
      "address": "0x0000000000000000000000000000000000000000",
      "proof": [
        "0x00314e565e0574cb412563df634608d76f5c59d9f817e85966100ec1d48005c0",
        "0x1ebaa930b8e9130423c183bf38b0564b0103180b7dad301013b18e59880541ae"
      ]
    },
    {
      "address": "0x0000000000000000000000000000000000000000",
      "proof": [
        "0xe9707d0e6171f728f7473c24cc0432a9b07eaaf1efed6a137a4a8c12c79552d9",
        "0x1ebaa930b8e9130423c183bf38b0564b0103180b7dad301013b18e59880541ae"
      ]
    }
  ],
  "private": [...]
}
```

Таким образом в админ панели данные о массиве `proof` для каждого адреса будут загружаться в IPFS ([как загрузить в IPFS?](./How-to-IPFS.md)). А в основном приложении данные будут считываться из IPFS. После чего будет происходить поиск по `address` для конкретного адреса и соответствующий `proof` будет передаваться на контракт при вызове вышеупомянутых методов.

Методы на чтение:

- `getMerkleRootAirDrop` - возвращает Root hash для вайтлиста, который используется на этапе airdrop.
- `getMerkleRootWhiteList` - возвращает Root hash для вайтлиста, который используется на этапе private presale.
- `getMerkleProofs` - возвращает IPFS хэш, в котором должен лежать JSON файл с массивами `proof`.
- `canClaimAirDrop` - проверяет, есть ли указанный кошелёк в вайтлисте airdrop.
- `isWhiteListed` - проверяет, есть ли указанный кошелёк в вайтлисте private presale.

Методы на запись:

- `setMerkleRootAirDrop` - устанавливает Root hash для вайтлиста, который используется на этапе airdrop. Может вызвать только `WHITE_LIST_MANAGER_ROLE`.
- `setMerkleRootWhiteList` - устанавливает Root hash для вайтлиста, который используется на этапе private presale. Может вызвать только `WHITE_LIST_MANAGER_ROLE`.
- `setMerkleProofs` - устанавливает IPFS хэш, в котором будет лежать JSON файл с массивами `proof`. Может вызвать только `WHITE_LIST_MANAGER_ROLE`.


### Другие методы на чтение

- `CAT` - строка `bytes32`, которую необходимо подписать пользователю перед вызовом метода `mint` на этапе public sale. Подробнее в описании метода `mint`.
- `MAX_AIRDROP_MINT` - максимальное количество NFT, которое можно получить на этапе airdrop.
- `MAX_WHITELIST_MINT` - максимальное количество NFT, которое можно получить на этапе private presale.
- `MAX_PUBLIC_MINT` - максимальное количество NFT, которое можно получить на этапе public sale.
- `MAX_SUPPLY` - максимальное количество NFT, которое могут сминтить все пользователи суммарно.
- `tokenURI` - возвращает ссылку на метаданные для указанного `tokenId`. Метаданные как правило хранятся на IPFS и содержат в себе различную информацию о конкретном токене - ссылку на картинку, описание, атрибуты и др. [Пример метаданных](https://ipfs.io/ipfs/QmNe7EebKaNuRoN2ov9nMuwHXQvXbYXCLM9W1nDBxnqLgL/1.json).
- `placeholderTokenUri` - возвращает ссылку на метаданные-заглушку, которая будет возвращаться для всех `tokenUri` до тех пор, пока `isRevealed === false`.
- `isRevealed` - состояние контракта, по умолчанию `false`. Пока `false`, все `tokenUri` будут возвращать `placheloderTokenUri`, то есть метаданные-заглушку. Когда станет `true`, `tokenUri` будет возвращать настоящие метаданные для каждого токена. Зачем это нужно? Представьте, что владелец продукта не хочет раскрывать пользователям, какие NFT они сминтили до тех пор, пока не пройдут все этапы минтинга. Для этого он может переключать состояние `isRevealed` и в нужный для себя момент раскрыть информацию о каждом сминченном токене всем пользователям.
- `allowedToClaimDropAmount` - количество NFT, которое пользователю осталось сминтить на этапе airdrop.
- `allowedToWhiteListMintAmount` - количество NFT, которое пользователю осталось сминтить на этапе private presale.
- `allowedToPublicMintAmount` - количество NFT, которое пользователю осталось сминтить на этапе public sale.
- `whiteListSalePrice` - стоимость покупки одной NFT на этапе private presale.
- `publicSalePrice` - стоимость покупки одной NFT на этапе public sale.
- `totalAirdropMint` - возвращает количество NFT, которое сминтил указанный адрес на этапе airdrop.
- `totalWhitelistMint` - возвращает количество NFT, которое сминтил указанный адрес на этапе private presale.
- `totalPublicMint` - возвращает количество NFT, которое сминтил указанный адрес на этапе public sale.
- `tokensOfOwner` - возвращает список ID токенов, которыми владеет указанный адрес.
- `totalSupply` - общее количество сминченных NFT.

### Другие методы на запись

- `setPlaceHolderUri` - устанавливает ссылку на метаданные-заглушку, которую будет возвращать `tokenUri` до тех пор, пока `isRevealed === false`. Может вызвать только `DEFAULT_ADMIN_ROLE`.
- `setTokenUri` - устанавливает ссылку на метаданные. Может вызвать только `DEFAULT_ADMIN_ROLE`.
- `toggleReveal` - переключает состояние `isRevealed` на противоположное (см. методы на чтение). Может вызвать только `SELL_PHASE_MANAGER_ROLE`.
- `claimAirdrop` - минтинг NFT на этапе airdrop. Принимает количество NFT и массив `proof`. Благодаря массиву `proof` контракт может проверить, есть ли пользователь в вайтлисте airdrop или нет.
- `whitelistMint` - покупка NFT на этапе private presale. Принимает количество NFT, нативный токен для оплаты, а так же массив `proof`. Благодаря массиву `proof` контракт может проверить, есть ли пользователь в вайтлисте private presale или нет.
- `mint` - покупка NFT на этапе public sale. Принимает количество NFT, нативный токен для оплаты, а так же сигнатуру подписи (`signature`). Сигнатуру подписи можно получить, подписав пользователем специальное сообщение. В нашем случае это строка `bytes32` слова `CAT` (см. методы на чтение). Данную строку необходимо прогнать через утилиту `toBytes` из `viem` и передать в метод `signMessage` из `wagmi`. Метод попросит пользователя подписать сообщение и после подписи вернёт сигнатуру, которую и необходимо передать в вызов `mint`. В итоге, пользователь сначала подписывает сообщение, а затем вызывается `mint`.